;; Analyzed by ClojureScript 1.7.122
{:use-macros nil, :excludes #{}, :name parinfer.reader, :imports nil, :requires nil, :uses nil, :defs {whitespace? {:protocol-inline nil, :meta {:file "/Users/swilliam/code/parinfer/site/../lib/src/parinfer/reader.cljc", :line 12, :column 7, :end-line 12, :end-column 18, :arglists (quote ([ch]))}, :name parinfer.reader/whitespace?, :variadic false, :file "../lib/src/parinfer/reader.cljc", :end-column 18, :method-params ([ch]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 12, :end-line 12, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ch]))}, in-code? {:protocol-inline nil, :meta {:file "/Users/swilliam/code/parinfer/site/../lib/src/parinfer/reader.cljc", :line 40, :column 7, :end-line 40, :end-column 15, :arglists (quote ([stack])), :doc "Next character is inside actual code."}, :name parinfer.reader/in-code?, :variadic false, :file "../lib/src/parinfer/reader.cljc", :end-column 15, :method-params ([stack]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 40, :end-line 40, :max-fixed-arity 1, :fn-var true, :arglists (quote ([stack])), :doc "Next character is inside actual code."}, valid-closer? {:protocol-inline nil, :meta {:file "/Users/swilliam/code/parinfer/site/../lib/src/parinfer/reader.cljc", :line 46, :column 7, :end-line 46, :end-column 20, :arglists (quote ([stack ch])), :doc "Determine if the given closing delimiter can be used next, assuming we are inside code."}, :name parinfer.reader/valid-closer?, :variadic false, :file "../lib/src/parinfer/reader.cljc", :end-column 20, :method-params ([stack ch]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 46, :end-line 46, :max-fixed-arity 2, :fn-var true, :arglists (quote ([stack ch])), :doc "Determine if the given closing delimiter can be used next, assuming we are inside code."}, prev-ch {:protocol-inline nil, :meta {:file "/Users/swilliam/code/parinfer/site/../lib/src/parinfer/reader.cljc", :line 21, :column 7, :end-line 21, :end-column 14, :arglists (quote ([stack]))}, :name parinfer.reader/prev-ch, :variadic false, :file "../lib/src/parinfer/reader.cljc", :end-column 14, :method-params ([stack]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 21, :end-line 21, :max-fixed-arity 1, :fn-var true, :arglists (quote ([stack]))}, in-comment? {:protocol-inline nil, :meta {:file "/Users/swilliam/code/parinfer/site/../lib/src/parinfer/reader.cljc", :line 35, :column 7, :end-line 35, :end-column 18, :arglists (quote ([stack])), :doc "Next character is inside a comment."}, :name parinfer.reader/in-comment?, :variadic false, :file "../lib/src/parinfer/reader.cljc", :end-column 18, :method-params ([stack]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 35, :end-line 35, :max-fixed-arity 1, :fn-var true, :arglists (quote ([stack])), :doc "Next character is inside a comment."}, opening-delim? {:name parinfer.reader/opening-delim?, :file "../lib/src/parinfer/reader.cljc", :line 9, :column 1, :end-line 9, :end-column 20, :meta {:file "/Users/swilliam/code/parinfer/site/../lib/src/parinfer/reader.cljc", :line 9, :column 6, :end-line 9, :end-column 20}}, closing-delim? {:name parinfer.reader/closing-delim?, :file "../lib/src/parinfer/reader.cljc", :line 10, :column 1, :end-line 10, :end-column 20, :meta {:file "/Users/swilliam/code/parinfer/site/../lib/src/parinfer/reader.cljc", :line 10, :column 6, :end-line 10, :end-column 20}}, in-str? {:protocol-inline nil, :meta {:file "/Users/swilliam/code/parinfer/site/../lib/src/parinfer/reader.cljc", :line 29, :column 7, :end-line 29, :end-column 14, :arglists (quote ([stack])), :doc "Next character is inside a string."}, :name parinfer.reader/in-str?, :variadic false, :file "../lib/src/parinfer/reader.cljc", :end-column 14, :method-params ([stack]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 29, :end-line 29, :max-fixed-arity 1, :fn-var true, :arglists (quote ([stack])), :doc "Next character is inside a string."}, matching-delim {:name parinfer.reader/matching-delim, :file "../lib/src/parinfer/reader.cljc", :line 4, :column 1, :end-line 4, :end-column 20, :meta {:file "/Users/swilliam/code/parinfer/site/../lib/src/parinfer/reader.cljc", :line 4, :column 6, :end-line 4, :end-column 20}}, push-char {:protocol-inline nil, :meta {:file "/Users/swilliam/code/parinfer/site/../lib/src/parinfer/reader.cljc", :line 126, :column 7, :end-line 126, :end-column 16, :arglists (quote ([state]))}, :name parinfer.reader/push-char, :variadic false, :file "../lib/src/parinfer/reader.cljc", :end-column 16, :method-params ([state]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 126, :end-line 126, :max-fixed-arity 1, :fn-var true, :arglists (quote ([state]))}, escaping? {:protocol-inline nil, :meta {:file "/Users/swilliam/code/parinfer/site/../lib/src/parinfer/reader.cljc", :line 24, :column 7, :end-line 24, :end-column 16, :arglists (quote ([stack])), :doc "Next character will be escaped."}, :name parinfer.reader/escaping?, :variadic false, :file "../lib/src/parinfer/reader.cljc", :end-column 16, :method-params ([stack]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 24, :end-line 24, :max-fixed-arity 1, :fn-var true, :arglists (quote ([stack])), :doc "Next character will be escaped."}, push-char* {:name parinfer.reader/push-char*, :file "../lib/src/parinfer/reader.cljc", :line 59, :column 1, :end-line 59, :end-column 21, :doc "Update the delimiter stack with the given character.", :meta {:file "/Users/swilliam/code/parinfer/site/../lib/src/parinfer/reader.cljc", :line 59, :column 11, :end-line 59, :end-column 21, :doc "Update the delimiter stack with the given character."}}}, :require-macros nil, :cljs.analyzer/constants {:seen #{:open :backup :else :default :x-pos :close :ch :stack :indent-delta :hierarchy}, :order [:ch :hierarchy :open :close :else :default :stack :x-pos :indent-delta :backup]}, :doc "a basic lisp reader for tracking parens and token states"}