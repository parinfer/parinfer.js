<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Parinfer - simpler Lisp editing</title>
  <meta name="description" content="Parinfer - simpler Lisp editing">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="css/fonts.css">
  <link rel="stylesheet" href="css/font-awesome-4.4.0.min.css">
  <link rel="stylesheet" href="codemirror/lib/codemirror.css">
  <link rel="stylesheet" href="css/lib/keys.css">
  <link rel="stylesheet" href="css/style.css">
  <link rel="stylesheet" href="css/theme.css">
</head>
<body class="no-mathjax">

<div class="sidebar">
  <h1>Par<em>infer</em></h1>
  <div class="credits">
    <a href="http://twitter.com/shaunlebron">@shaunlebron</a> |
    <a href="https://github.com/shaunlebron/parinfer">GitHub</a>
  </div>
  <div id="toc">
    <span class="caption">building table of contents...</a>
  </div>
</div>

<div id="app">

<!------------------------------------------------------------------------------------>

<div class="wrapper only-mobile">
<section>
  <h1>Par<em>infer</em></h1>
  <div class="credits">
    <a href="http://twitter.com/shaunlebron">@shaunlebron</a> |
    <a href="https://github.com/shaunlebron/parinfer">GitHub</a>
  </div>

<div class="interact">
<i class="fa fa-desktop fa-lg"></i>
<strong>Best viewed</strong> on wide desktop browsers.  Sorry for the inconvenience.
</div>

</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section>
<p class="subtitle">
Let's simplify the way we write Lisp...
</p>

<div class="interact">
<i class="fa fa-keyboard-o fa-lg"></i>
<strong>Try it!</strong> Interrupt the animations below to try it for yourself. Click outside to restore it.
</div>


<div>
<div class="caption"><strong>Parinfer's "Indent Mode"</strong> rearranges parens when you change indentation:</div>
<textarea id="code-intro-indent">
</textarea>
</div>

<div>
<div class="caption"><strong>Insert or delete a line</strong> without rearranging parens:</div>
<textarea id="code-intro-insert">
</textarea>
</div>

<div>
<div class="caption"><strong>Comment a line</strong> without rearranging parens:</div>
<textarea id="code-intro-comment">
</textarea>
</div>

<div>
<div class="caption"><strong>Basic Paredit without hotkeys</strong> thanks to simple paren inference. (wrap, splice, slurp, barf)</div>
<textarea id="code-intro-paredit">
</textarea>
</div>

<div>
<div class="caption"><strong>Preserve indentation</strong> when editing in "Paren Mode":</div>
<textarea id="code-intro-paren">
</textarea>
</div>
</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper fold">
<section>

<p>
<span class="title">Parinfer</span> is a proof-of-concept editor mode for Lisp
programming languages.  It simplifies the way we write Lisp by auto-adjusting
parens when indentation changes and vice versa. The hope is to make basic
Lisp-editing easier for newcomers and experts alike, while still allowing
existing plugins like Paredit to satisfy the need for more advanced operations.
</p>

<ul>
  <li>Source code: <a href="http://github.com/shaunlebron/parinfer">http://github.com/shaunlebron/parinfer</a><br>
  <li>Created by: <a href="http://twitter.com/shaunlebron">@shaunlebron</a><br>
  <li>Download (work in progress): <a href="#editor-plugins">Editor Plugins</a>
</ul>

<div class="interact">
<i class="fa fa-book fa-lg"></i>
<strong>Read on</strong> for a full exploration of the motivations, rules, and effects of Parinfer.
</div>

</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="introduction">
<h2>Introduction</h2>

<p>
<strong>Lisp is often dismissed</strong> as an undesirable programming syntax
due to excessive parentheses.  Those who have adopted Lisp have long recognized its
amazing strengths, but there is still a widely held uncertainty among newcomers about
how or even <em>why</em> we must manage so many parens.  As a result, Lisp's
unique power remains invisible to most under this guise of difficulty.
</p>

<p>
<strong>Newcomers aren't satisfied</strong> with the current tools designed for
editing Lisp.  Expert-level editors (Emacs, Vim) and advanced hotkeys (Paredit)
are powerful but steepen the learning curve.  And alternative syntaxes (Lisps
without parens) have faltered since they sacrifice some of Lisp's power that
seasoned users aren't willing to part with.
</p>

<p>
<strong>Parinfer is a new system</strong> that tries instead to fix this
problem at its source.  We formally define the relationship between Parens and
Indentation. With it, we create an intuitive editor mode to make paren
management fun and easy without sacrificing power.  We demonstrate this through
interactive proof-of-concept demos here, providing capabilities for:
</p>

<ul class="features">
<li> making code auto-adhere to formatting conventions
<li> influencing expression-nesting with indentation
<li> maintaining indentation when expressions shift
<li> allowing
<a href="http://danmidwood.com/content/2014/11/21/animated-paredit.html">Paredit</a>-like
features without hotkeys
</ul>

<blockquote class="aside">
<p>
<strong>NOTE: When I say "parens"</strong> (parentheses), I also mean <em>[square]</em> or <em>{curly}</em>
brackets.  Some Lisps (e.g.
<a href="http://racket-lang.org/">Racket</a>,
<a href="http://clojure.org/">Clojure</a>)
use these extra delimiters to help visually separate certain constructs.
</p>
</blockquote>


</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="uncovering-lisp">
<h3>Uncovering Lisp</h3>

<p>
Most programming languages have several syntax rules.  Lisp has one:
everything is a list.  The first element is a function name, and the rest are
its arguments.  Thus, the language is simply a collection of compile- and
run-time functions, trivially extensible.
</p>

<div class="two-col">
<div class="col">
<div class="caption"><strong>C Style</strong> expressions:</div>
<textarea id="code-c-expr">
foo(1, 2, 3);
const a = 1;
if (a == 1) foo(); else bar();
const b = (a == 1) ? 2 : 3;
</textarea>
</div>

<div class="col">
<div class="caption"><strong>Lisp Style</strong> expressions:</div>
<textarea id="code-lisp-expr">
(foo 1 2 3)
(def a 1)
(if (= a 1) (foo) (bar))
(def b (if (= a 1) 2 3))
</textarea>
</div>
</div>

<p>
But parentheses in Lisp are infamous for bunching together at the end of long
expressions. This indentation
<a href="https://en.wikipedia.org/wiki/Indent_style#Lisp_style">convention</a>
can be jarring at first if you are used to curly braces in other languages
being on their own lines:
</p>

<div class="two-col">
<div class="col">
<div class="caption"><strong>C Style</strong> indentation (unusual in Lisp):</div>
<textarea id="code-c-indent">
(defn foo [a b]
  (let [
     x (+ a b)
    ]
    (println "The sum is" x)
  )
)
</textarea>
</div>

<div class="col">
<div class="caption"><strong>Lisp Style</strong> indentation:</div>
<textarea id="code-lisp-indent">
(defn foo [a b]
  (let [x (+ a b)]
    (println "The sum is" x)))
</textarea>
</div>
</div>

<p>
The idea behind this convention is to make every line inform with content
rather than just parens. Readability is helped by employing a Python-like
indentation style.  This achieves a sort of balance&mdash; Indentation allows
you to <em>skim</em> while the parens allow you to <em>inspect</em>:</p>

<div class="two-col">
<div class="col">
<div class="caption"><strong>Skim</strong> by focusing on indentation</div>
<textarea id="code-skim">
(defn foo [a b]
  (let [x (+ a b)]
    (println "The sum is" x)))
</textarea>
</div>

<div class="col">
<div class="caption"><strong>Inspect</strong> parens with your cursor when needed</div>
<textarea id="code-inspect">
(defn foo [a b]
  (let [x (+ a b)]
    (println "The sum is" x)))
</textarea>
</div>
</div>

<p>
Though both <em>perspectives</em> are visible at once, we must focus on one at
a time.  A
<a href="https://twitter.com/paulg/status/588511912331055104">LEGO analogy</a>
helps here. Imagine each list in the previous example as a LEGO block
stacked over its parent. Checking the sides to see the layers below is like
checking the parens at the end of a line.
</p>

<div class="two-col">
<div class="col">
<div class="caption"><strong>Indentation</strong> implies nesting.</div>
<img class="lego-img" src="img/lego-indent.png">
</div>

<div class="col">
<div class="caption"><strong>Tilting</strong> clarifies nesting (close-parens shown).</div>
<img class="lego-img" src="img/lego-parens.png">
</div>
</div>

<p>
This is a physical analog to the way we read Lisp code.  Now let's look at the
space of tooling solutions that we use for <em>writing</em> Lisp code and
specifically how Parinfer can help.
</p>

</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="tools-for-writing-lisp">
<h3>Tools for Writing Lisp</h3>

<p>
In the previous section, we saw how Parens and Indentation provide two
perspectives for reading Lisp code.  Unfortunately, this incurs some redundancy
when <em>writing</em> Lisp since we must edit both for every change, ensuring
that one will correctly imply the other.
</p>

<p>
There are existing tools to help with this.  To best represent how Parinfer
compares to them, we will represent this complex space of tooling in a way that
can be visually compared below.
</p>

<div class="interact">
<i class="fa fa-gear fa-lg"></i>
<strong>The black gear</strong> represents the current action we are taking.
</div>

<p>
<strong>The menial and default</strong> way to edit Lisp is to manually ensure
our parens are balanced after inserting or removing them.  Then, we adjust the
indentation to match it in kind.  This back-and-forth happens for most editing
tasks.
</p>

<div class="gearbox" id="naive-gears">
</div>

<p>
<strong>Existing tools automate</strong> some of these editing tasks.
For example, <em>Paredit</em> forces you to transform or add parens in a
balanced way through special hotkeys.  And <em>Auto-indent</em> allows you to
auto-correct indentation of selected lines when desired.  This automates
the tasks, but the back-and-forth actions are still manually triggered.</p>

<div class="gearbox" id="helper-gears">
</div>

<p>
<strong>Parinfer is a new tool to <em>combine and simplify</em></strong> this
type of automation by naturally keeping Parens and Indentation in lockstep.  It
formally <em>infers</em> changes to one based on the other.  The back-and-forth
actions have been reduced with special modes, which we will explore next.
</p>

<div class="gearbox" id="parinfer-gears">
</div>

</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="writing-with-parinfer">
<h3>Writing with Parinfer</h3>

<p>
As we saw with the previous visualization, Parinfer will infer some changes to
keep Parens and Indentation inline with one another.  To keep this inference
simple and predictable, we have the user explicitly choose the degree of
freedom that <em>they</em> want full control of, while relinquishing some
control of the other to <em>Parinfer</em>.
</p>

<p>
Thus, Parinfer consists of two modes:
</p>

<ol>
<li>
<strong>Indent Mode</strong> gives you full control of indentation, while
Parinfer corrects parens.<br>
</li>
<li>
<strong>Paren Mode</strong> gives you full control of parens, while Parinfer
corrects indentation.<br>
</li>
</ol>

<div class="interact">
<i class="fa fa-lightbulb-o fa-lg"></i>
<strong>To make this easier</strong>, Indent Mode is default. Paren Mode can be an advanced option.
</div>

<p>
Some noteworthy unintended use-cases which we will explore later:
</p>

<ul>
  <li>Indent Mode allows Paredit-like features without hotkeys.</li>
  <li>Paren Mode can be used to fix incorrectly indented files before using with Indent Mode.</li>
</ul>

</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="mathematical-foundation">
<h3>Mathematical Foundation</h3>

<div class="interact">
<i class="fa fa-rocket fa-lg"></i>
<strong>Feel free to <a href="#indent-mode">skip this</a></strong> if you have no interest in the math that makes Parinfer possible.
</div>

<p>
The foundation of Parinfer relies on a few somewhat formalized definitions and
properties:
</p>

<div class="math-page mathjax">
<p>
We wish to define properties that each Parinfer mode should exhibit.
</p>

<p>
With the following definitions:
<ul>
  <li>$I$ = (Indent Mode) function accepting code text and returning new text.</li>
  <li>$P$ = (Paren Mode) function accepting code text and returning new text.</li>
  <li>$R$ = (Reader) function accepting code text and returning its AST data.</li>
</ul>
</p>

<p>
The following should be true:
<ul>
  <li>let $y = P(x)$
        <div class="side-note">
          $\leftarrow$ run Paren-Mode on $x$ to get $y$
        </div>
    <ul>
      <li>$\Longrightarrow R(x) = R(y)$
        <div class="side-note">
          $\leftarrow$ Paren-Mode should never change the AST
        </div>
      <li>$\Longrightarrow P(y) = y$
        <div class="side-note">
          $\leftarrow$ Paren-Mode should be idempotent
        </div>
      <li>$\Longrightarrow I(y) = y$
        <div class="side-note">
          $\leftarrow$ Indent-Mode should never change the result of Paren-Mode
        </div>
    </ul>
</ul>

<ul>
  <li>let $z = I(x)$
        <div class="side-note">
          $\leftarrow$ run Indent-Mode on $x$ to get $z$
        </div>
    <ul>
      <li>$\mathrel{\rlap{\hskip .5em/}}\Longrightarrow R(x) = R(z)$
        <div class="side-note">
          $\leftarrow$ Indent-Mode may change the AST (by design)
        </div>
      <li>$\Longrightarrow I(z) = z$
        <div class="side-note">
          $\leftarrow$ Indent-Mode should be idempotent
        </div>
    </ul>
</ul>
</p>

</div>

<p class="mathjax">
The actual operations performed by the modes rely on a formal definition
of what it means for Lisp code to be "correctly formatted".  We establish an
invariant&mdash; something that must be true for every line of code.  From that,
Parinfer corrects indentation or parens simply by choosing correct values for
$i_n$ or $p_n$ (defined later) to satisfy this invariant:
</p>

<ul class="mathjax">
  <li><strong>Indent Mode</strong> forces correct values of $p_n$</li>
  <li><strong>Paren Mode</strong> forces correct values of $i_n$</li>
</ul>

<p>
The following is a concise reference (not a guide) to establishing this
invariant that Parinfer's modes rely on.
</p>

<div class="math-page mathjax">
<p>
We wish to define necessary conditions for determining if a given file of Lisp
code is "correctly formatted".
</p>

<p>
We start with a clarification that we only consider non-empty lines (i.e. lines
that have at least one non-whitespace, non-comment token).  Thus, all following
references to line number $n$ will refer to the $n$th non-empty line.
</p>

<p>
To proceed, we define the following:

<ul>
<li>
$t_n$ = (tokens) index of non-whitespace, non-comment tokens at line $n$
</li>
<li>
$i_n$ = (indentation) x-position of $t_n[0]$
</li>
<li>
$p_n$ = (parens) number of close-parens at the end of $t_n$
</li>
<li>
$s_n$ = (stack) index of x-positions of all open-parens unclosed before $t_n[-p_n]$
</li>
</ul>
</p>

<p>
Next, we define a function which determines if a line's indentation is valid:

<ul>
  <li>$f(i,p,s) = ( x_\text{min} \lt i \leq x_\text{max} )$
    <div class="side-note">$\leftarrow$ verifies indentation is within a threshold defined below</div>
  </li>
</ul>
</p>

<p>
where:
<ul>
  <li>$x_\text{min} = \begin{cases} s[-p-1] & \text{if } |s| > p, \\ -1 & \text{otherwise} \end{cases}$
    <div class="side-note">
      $\leftarrow$ x-position of open-paren of parent list if it exists
    </div>
  </li>
  <li>$x_\text{max} = \begin{cases} s[-p] & \text{if } p \gt 0, \\ \infty & \text{otherwise} \end{cases}$
    <div class="side-note">
      $\leftarrow$ x-position of open-paren of previous sibling if it is a list
    </div>
  </li>
</ul>
</p>


<p>
Finally, we define that a file of Lisp code is "correctly formatted" if:

<ol>
  <li>for every line $n > 0$:
    <ul>
      <li>$t_n[0] \ne $ ")", and
        <div class="side-note">
          $\leftarrow$ no line may start with a close-paren
        </div>
      </li>
      <li>$f(i_n, p_{n-1}, s_{n-1})$ is true
        <div class="side-note">
          $\leftarrow$ indentation threshold that we defined above
        </div>
      </li>
    </ul>
  </li>
  <li>and for the last line $N$
    <ul>
      <li>$|s_N| = p_N$
        <div class="side-note">
          $\leftarrow$ all open-parens must be closed at the last line
        </div>
      </li>
    </ul>
  </li>
</ol>
</p>

</div>

<p>
These rules are necessary and sufficient for determining when indentation is
what we consider "unambiguous", but they are not sufficient in determining if
code is "pretty". For example:

<ul>
<li>single-line files are okay</li>
<li>"tab" lengths are flexible (one space, two spaces, etc)</li>
<li>indentation of sibling lines are not required to be aligned</li>
</ul>
</p>

<p>
Formal descriptions of the actual operations performed by the modes are
pending, but informal ones follow in their respective sections below.
</p>

</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="indent-mode">
<h2>Indent Mode</h2>

<p>
Indent Mode gives you full control of indentation, while Parinfer corrects or
inserts close-parens where appropriate.  Specifically, it only touches the
groups of close-parens at the end of each line.  As a visual cue, we
<em>slightly dim</em> these parens to signify their inferred nature.
</p>

<div class="interact">
<i class="fa fa-keyboard-o fa-lg"></i>
<strong>Try it!</strong> Interrupt the animations below to try it for yourself. Click outside to restore it.
</div>

<div>
<div class="caption"><strong>Indent</strong> to influence the structure of your code:</div>
<textarea id="code-indent">
</textarea>
</div>

<div>
<div class="caption"><strong>Indent further</strong> to reach different thresholds:</div>
<textarea id="code-indent-far">
</textarea>
</div>

<div>
<div class="caption"><strong>Indent multiple lines</strong> to see its effect:</div>
<textarea id="code-indent-multi">
</textarea>
</div>

<p>
You can select multiple lines and adjust their indentation the standard way using
the controls below.  If you are familiar with Paredit, these operations are
roughly equivalent to those listed.
</p>

<table class="paredit-table">
<tr>
<th>Controls</th>
<th>Description</th>
<th>Paredit equivalent</th>
</tr>
<tr>
<td><kbd class="light">Tab</kbd></td>
<td>indent line(s)</td>
<td>slurp line(s) down</td>
</tr>
<tr>
<td><kbd class="light">Shift</kbd> + <kbd class="light">Tab</kbd></td>
<td>dedent line(s)</td>
<td>barf line(s) down</td>
</tr>
</table>
</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="interesting-consequences">
<h3>Interesting Consequences</h3>

<div>
<div class="caption"><strong>Insert or delete a line</strong> without rearranging parens:</div>
<textarea id="code-line">
</textarea>
</div>

<div>
<div class="caption"><strong>Comment a line</strong> without rearranging parens:</div>
<textarea id="code-comment">
</textarea>
</div>
</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="indent-how-it-works">
<h3>How it works</h3>

<p>
We perform the following steps to rearrange close-parens based on indentation.<br>
<span class="side-point">We will refer to these later as rules #1, #2, #3 and #4.</span>
</p>

<ol>
<li> <span class="removed">remove</span> all unmatched close-parens (for housekeeping)
<li> <span class="removed">remove</span> all close-parens at the start and end of each line
<li> <span class="kept">keep</span> all close-parens <em>inside</em> each line
<li> for every resulting unmatched open-paren:
  <ul>
  <li> <span class="inserted">insert</span> a matching close-paren at the end of its line or its last non-empty indented line
  </ul>
</ol>

<div class="interact">
<i class="fa fa-keyboard-o fa-lg"></i>
<strong>Try it!</strong> Edit the code below on the left to see how parens are inferred on the right.
</div>


<div class="two-col">
<div class="col">
<div class="caption"><strong>Input:</strong> close-parens are removed or kept.</div>
<textarea id="code-indent-input">
(defn on-click []
  (swap! s update-in [:x] inc)
  )

(defn component
  "my docstring."
  [messages]
  [:div]
   (for [[i msg] messages]
     [:div msg])
  )
</textarea>
</div>

<div class="col">
<div class="caption"><strong>Output:</strong> close-parens are inserted.</div>
<textarea id="code-indent-output">
</textarea>
</div>
</div>

<p>
This is the gist of what's happening.  There are more steps performed, but we
will just explore their effects in the next section.
</p>
</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="paredit-emerges">
<h3>Paredit emerges</h3>

<p>
You should be aware that the steps in the previous section have a side effect on
what you type.  Interestingly, these effects translate into four of the main
<a href="">Paredit</a>
 operations.
</p>

<table class="paredit-table light-keys">
<tr>
<th align="right">Cause</th>
<th align="center">Effect</th>
<th align="left">Description</th>
</tr>

<tr>
<td align="right">Insert <kbd>(</kbd></td>
<td align="center">Wrap</td>
<td align="left">
inserts a matching <kbd>)</kbd> as far as it can
<div class="side-point">
i.e. "wraps" all possible elements to the right of your cursor
</div>
</td>
</tr>

<tr>
<td align="right">Insert <kbd>)</kbd></td>
<td align="center">Barf</td>
<td align="left">
removes the original <kbd>)</kbd> when inserted inside a matching pair
<div class="side-point">
i.e. the current list "barfs" out all elements to the right of your cursor
</div>
</td>
</tr>

<tr>
<td align="right">Delete <kbd>(</kbd></td>
<td align="center">Splice</td>
<td align="left">
removes the matching <kbd>)</kbd>
<div class="side-point">
i.e. "splices" the current list into its parent (or simply "unwraps" it)
</div>
</td>
</tr>

<tr>
<td align="right">Delete <kbd>)</kbd></td>
<td align="center">Slurp</td>
<td align="left">
inserts another <kbd>)</kbd> as far as it can
<div class="side-point">
i.e. the current list "slurps" all elements to the right of your cursor
</div>
</td>
</tr>

</table>

<p>
We illustrate these operations in the following examples.
</p>

</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="inserting-parens">
<h3>Inserting Parens</h3>

<div>
<div class="caption"><strong>Wrap</strong> by inserting an open-paren. It will auto-close as far as it can, due to rule #4.</div>
<textarea id="code-wrap">
</textarea>
</div>

<div>
<div class="caption"><strong>Barf</strong> by inserting a close-paren before another.
Notice the original is removed, due to rule #1.</div>
<textarea id="code-barf">
</textarea>
</div>

<div class="caption">
<div class="question">
<i class="fa fa-question-circle"></i>
Why can't I insert a close-paren in certain places?
</div>
<div class="answer">Its corresponding open-paren must be there first. (see rule #1)</div>
</div>
</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="deleting-parens">
<h3>Deleting Parens</h3>

<div>
<div class="caption"><strong>Splice</strong> by removing an open-paren. Its corresponding close-paren is removed, due to rule #1.</div>
<textarea id="code-splice">
</textarea>
</div>

<div>
<div class="caption"><strong>Slurp</strong> by deleting a close-paren inside a line. It is replaced further down, due to rule #4.</div>
<textarea id="code-slurp">
</textarea>
</div>

<div class="caption">
<div class="question">
<i class="fa fa-question-circle"></i>
Why can't I delete a close-paren in certain places?
</div>
<div class="answer">You cannot delete an inferred close-paren. It is replaced as soon as you delete it. (see rule #4)</div>
</div>
</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="knowing-when-parens-move-in-indent-mode">
<h3>Knowing When Parens Move</h3>

<p>
As a courtesy, <em>Indent Mode</em> will not move your parens until you are done typing
in front of them.  Just move your cursor away when you're done.  A helpful
analogy might be to think of your cursor as a <em>paperweight</em> that keeps your
parens from blowing away.
</p>

<div>
<div class="caption"><strong>Paren displaced</strong> when your cursor moves to another line. (displaced due to indentation)</div>
<textarea id="code-displaced">
</textarea>
</div>

<div>
<div class="caption"><strong>Paren not displaced</strong> since you were given the chance to block it. (paren not at end of line)</div>
<textarea id="code-not-displaced">
</textarea>
</div>
</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="pressing-enter">
<h3>Pressing Enter</h3>

<p>
Pressing enter will result in your cursor moving to an auto-indented line, as
expected.  Just keep in mind that the inferred parens won't move until you
actually type something on the new line.
</p>

<div>
<div class="caption">
<strong>Watch where the cursor is</strong> when pressing Enter. Inferred parens not displaced until typing. (rule #2)
</div>
<textarea id="code-enter">
</textarea>
</div>
</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="inserting-quotes">
<h3>Inserting Quotes</h3>

<p>
<em>Parinfer</em> cannot infer anything about quote positions like it can with parens.
So it doesn't try to do anything special with them, other than abandon
processing if imbalanced quotes are detected.
</p>

<div>
<div class="caption"><strong>Quote</strong> insertion allows temporary paren imbalances until quote is closed:</div>
<textarea id="code-string">
</textarea>
</div>

<div class="warning">
<div class="warning-title">
<i class="fa fa-lg fa-warning"></i>
WARNING: Always make sure quotes are balanced when inside comments!
</div>
<div class="warning-body">
If there is an unclosed quote before a comment, which itself contains
imbalanced quotes, they will balance each other out and fool <em>Parinfer</em> into
thinking it is okay for processing.
</div>
</div>

<div class="two-col">
<div class="col">
<div class="caption">
<i class="fa fa-lg fa-times red"></i>
<strong>BAD:</strong> An unclosed string in a comment can cause corrupted strings.
</div>
<textarea id="code-warn-bad">
</textarea>
</div>

<div class="col">
<div class="caption">
<i class="fa fa-lg fa-check green"></i>
<strong>GOOD</strong>: Balance the quotes in the comment to prevent the problem.
</div>
<textarea id="code-warn-good">
</textarea>
</div>
</div>
</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="paren-mode">
<h2>Paren Mode</h2>

<p>
Paren Mode gives you full control of parens, while Parinfer corrects indentation.
You can still adjust indentation, but you won't be able indent/dedent past certain
boundaries set by parens on previous lines.  As a courtesy, this mode also
maintains relative indentation of child elements when their parent expressions
shift.
</p>

<p>
Here are some things that cannot be done in Indent Mode:
</p>

<div>
<div class="caption"><strong>Tune indentation</strong> without worrying about crossing a paren boundary:</div>
<textarea id="code-paren-tune">
</textarea>
</div>

<div>
<div class="caption"><strong>Avoid fracturing</strong> a multi-line expression when pushing its open-paren forward:</div>
<textarea id="code-paren-frac">
</textarea>
</div>

<div>
<div class="caption"><strong>Indentation is maintained</strong> when parens shift, ensuring reversible operations:</div>
<textarea id="code-paren-comment">
</textarea>
</div>

<div>
<div class="caption"><strong>Nested expressions</strong> become automatically indented (temporary imbalances allowed):</div>
<textarea id="code-paren-wrap">
</textarea>
</div>
</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="paren-how-it-works">
<h3>How it works</h3>

<p>
Paren Mode performs the following steps:
</p>

<ol>
<li> Move close-parens at the start of a line to the end of the previous non-empty line.
<li> Clamp the indentation of a line to the following range:
  <ul>
    <li> min: x-position of the parent open-paren (if it exists)
    <li> max: x-position of the open-paren belonging to the previous non-empty line's last close-paren
  </ul>
<li> Child elements of moved expressions should maintain their original relative indentation to them.
<li> Cancel processing if there are any unmatched parens.
</ol>
</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="switching-modes">
<h3>Switching Modes</h3>

<p>
If there are paren imbalances in Paren Mode, the code is not processed, and you
are prevented from switching to Indent Mode.  This safely quarantines the
imbalances that could be misinterpreted in Indent Mode.  Thus, Paren Mode gives
you an environment to fix them, after which the code is automatically formatted
and ready for Indent Mode should you choose to switch.
</section>
</div>
</p>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="fixing-existing-files">
<h3>Fixing existing files</h3>

<p>
We must take parens literally when opening an existing file. Incidentally,
Paren Mode is perfect for this job, so we preprocess existing files with it
before allowing the switch to Indent Mode.
</p>

<div class="interact">
<i class="fa fa-keyboard-o fa-lg"></i>
<strong>Try it!</strong> Edit the code below on the left to see how it is formatted on the right.
</div>

<div class="two-col">
<div class="col">
<div class="caption"><strong>Input:</strong> Any existing file. Must be correctly balanced, but can be incorrectly formatted.</div>
<textarea id="code-paren-input">
(defn foo
  ([a]
    (foo a 1))
  ([a b]
    (let [sum (+ a b)
          prod (* a b)
          result { ; gather vals
            :sum sum
            :prod prod
          }]
      result)
    ; TODO: something
    ))
</textarea>
</div>

<div class="col">
<div class="caption"><strong>Output:</strong> Made ready for Parinfer by correcting indentation and moving close-parens.</div>
<textarea id="code-paren-output">
</textarea>
</div>
</div>

<p>
Notice that this process is NOT an invasive pretty-printer.  Newline characters
are never added or removed.  It preserves as much as it can of the original
code, only moving close-parens and changing indentation.
</p>

<p>
<em>Parinfer</em> should remain in Paren Mode if the file cannot be processed, due
to the reasons stated in the previous section.
</p>
</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="knowing-when-parens-move-in-paren-mode">
<h3>Knowing When Parens Move</h3>

<p>
As a courtesy, <em>Paren Mode</em> will not move your parens while your cursor
is behind them. Just move your cursor away when you're done.  A helpful
analogy might be to think of your cursor as a <em>paperweight</em> that keeps
your parens from blowing away.
</p>

<div>
<div class="caption"><strong>Parens displaced</strong> only after they are balanced.</div>
<textarea id="code-displaced-after-balance">
</textarea>
</div>

<div>
<div class="caption"><strong>Parens not displaced</strong> if the cursor is behind it (allowing you to type).</div>
<textarea id="code-not-displaced-on-enter">
</textarea>
</div>

<div>
<div class="caption"><strong>Parens displaced</strong> if the cursor is no longer behind them.</div>
<textarea id="code-displaced-after-cursor-leaves">
</textarea>
</div>

</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="conclusions">
<h2>Conclusions</h2>
</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="benefits">
<h3>Benefits</h3>

<p>
Inferring parentheses based on indentation seems to lead to simpler editing
mechanics for Lisp code.  It leads to a system that keeps our code formatted
well. And it allows us to use paredit-like features without hotkeys.
</p>

<p>
I think the biggest win is its potential to quell fear of managing end-of-line
parens by enforcing a direct driving relationship with indentation.
</p>

<p>
And just like <em>Paredit</em> it maintains paren-balanced code.
</p>
</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="downsides">
<h3>Downsides</h3>

<p>
The rules for what happens when inserting/deleting parens must be learned.
Also, the case necessitating a "Paren Mode" comes at the cost of forcing the
user to understand when and how to switch editing modes.
</p>

<p>
Also, the preprocessor step performed when opening files will cause more
formatting-related changes in your commit history when collaborating with
others not using <em>Parinfer</em>.
</p>
</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="final-thoughts">
<h3>Final Thoughts</h3>

<p>
Regardless of how we choose to edit our Lisp code, there seems to always be a
balancing act between maintaining the simplicity of how we interact with the
editor and accepting some editor complexity to gain automation over these
powerful but numerous parens.
</p>

<p>
Building the interactive examples for this page has allowed me to explore how
well Parinfer can play this balancing act, but only in a demo environment.
The <em>real test</em> will come once it becomes available to major editors.
See <a href="#editor-plugins">editor plugins</a> for progress.
</p>

</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="appendix">
<h2>Appendix</h2>
</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="source-code">
<h3>Source Code</h3>

<p>
The text formatting code is intended to be editor-agnostic.  It is implemented
in straightforward, imperative JavaScript, optimized for speed and designed
to be easy to port to other languages. There is a test suite which is also
designed to be easy to port with all test cases represented in JSON files.
</p>

<p>
The editor demos on this site are created in CodeMirror with hooks to apply our
formatters and update cursor position.  Source code for both the library and site
are available on github:
</p>

<p>
<i class="fa fa-lg fa-code-fork"></i> <a href="http://github.com/shaunlebron/parinfer">http://github.com/shaunlebron/parinfer</a>
</p>

</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="editor-plugins">
<h3>Editor Plugins</h3>

<p>
Though Parinfer is still in early development, several contributors have
started working on plugins for major editors.  Currently, most of them spin up
an instance of Node to leverage a single, canonical implementation via RPC.
This allows core bug fixes to reach all editor plugins until the core is
stabilized and ready for proper porting.
</p>

<p>
<strong>Works in Progress:</strong>
</p>

<ul>
  <li>
    <a href="https://github.com/oakmac/atom-parinfer">atom-parinfer</a>
    for <a href="https://atom.io/">Atom</a>
  </li>
  <li>
    <a href="https://github.com/snoe/nvim-parinfer.js">nvim-parinfer.js</a>
    for <a href="https://neovim.io/">neovim</a>
  </li>
  <li>
    <a href="https://github.com/bhurlow/vim-parinfer">vim-parinfer</a>
    for <a href="http://www.vim.org/">Vim</a>
  </li>
  <li>
    <a href="https://github.com/Microsoft/vscode-parinfer">vscode-parinfer</a>
    for <a href="https://code.visualstudio.com/">Visual Studio Code</a>
  </li>
  <li>
    <a href="https://github.com/oakmac/sublime-text-parinfer">sublime-text-parinfer</a>
    for <a href="http://www.sublimetext.com/">Sublime Text</a>
  </li>
  <li>
    <a href="https://github.com/edpaget/parinfer-mode">parinfer-mode</a>
    or
    <a href="https://github.com/dongcarl/parinfer">elisp-parinfer</a>
    for <a href="https://www.gnu.org/software/emacs/">Emacs</a>
  </li>
  <li>
    <a href="https://github.com/hiram-madelaine/codemirror-parinfer">codemirror-parinfer</a>
    for <a href="https://codemirror.net/">CodeMirror</a>
  </li>
  <li>
    <a href="https://github.com/mauricioszabo/lt_parinfer">lt_parinfer</a>
    for <a href="http://lighttable.com/">Light Table</a>
  </li>
</ul>

<p>
Parinfer is available for some REPL environments as well:
</p>

<ul>
  <li>
    <a href="https://github.com/mfikes/replete">Replete</a> for iOS
  </li>
  <li>
    <a href="https://github.com/binaryage/dirac">Dirac DevTools</a> for Google Chrome
  </li>
  <li>
    <a href="http://jaredforsyth.com/reepl/">Reepl</a> for the browser
  </li>
</ul>

<div class="interact">
<i class="fa fa-commenting-o fa-flip-horizontal fa-lg"></i>
<a href="https://github.com/shaunlebron/parinfer/issues/new?title=new%20plugin">Let me know</a>
if you're working on a plugin, or
<a href="https://github.com/shaunlebron/parinfer/wiki/Make-a-Plugin">check the wiki</a>
for extra guidance.  Thanks!
</div>

</section>
</div>

<!------------------------------------------------------------------------------------>

<div class="wrapper">
<section id="acknowledgements">
<h3>Acknowledgements</h3>

<ul>

  <li>
    <a href="https://elpa.gnu.org/packages/adjust-parens.html">adjust-parens</a>
    is an earlier idea for adjusting close-parens based on indentation in Emacs.
  </li>

  <li>
    <a href="https://github.com/Malabarba/aggressive-indent-mode">aggressive-indent-mode</a>
    re-indents code after every keystroke in Emacs, to remove the back-and-forth actions mentioned
    in the <a href="#tools-for-writing-lisp">Tools for Writing Lisp</a> section.
    I believe Parinfer's Paren Mode is less aggressive in that it keeps
    indentation within thresholds rather than hard limits (more on this in a
    future section).
  </li>

  <li>
    <a href="http://haml.info">Haml</a>,
    <a href="http://slim-lang.com/">Slim</a>,
    <a href="http://jade-lang.com/">Jade</a> &mdash;
    comparing these indented-templating languages to Clojure's Hiccups is what
    made me realize Lisp close-parens could be inferred from indentation.
  </li>

  <li>
    Thanks to
    <a href="https://github.com/boxed">Anders Hovm√∂ller</a> and
    <a href="https://github.com/darwin">Antonin Hildebrand</a> for humoring me on an
    <a href="https://github.com/boxed/indent-clj/issues/1">early crazy idea</a>
    and connecting me to some ideas about indentation and structural editors.
  </li>

  <li>
    <a href="http://readable.sourceforge.net/">sweet-expressions</a>,
    <a href="http://srfi.schemers.org/srfi-49/srfi-49.html">i-expressions</a>,
    <a href="https://github.com/boxed/indent-clj">indent-clj</a>, et al
    explored how parentheses can be inferred (but hidden).
  </li>

  <li>
    <a href="http://learnyouahaskell.com/higher-order-functions#function-application">Haskell's $ operator</a>
    infers a closing paren after all expressions to the right, even after
    subsequent indented expressions, which is basically what Indent Mode in
    Parinfer does.
  </li>

  <li>
    <a href="https://github.com/Cirru/sepal.clj">Cirru Sepal in Clojure</a>
    has an interesting approach to inferring Clojure parens from indentation
    and other syntax sugar&mdash; <code>$</code>, <code>$ []</code>, <code>$
    {}</code> and <code>,</code>.
  </li>

  <li>
    It's worth mentioning
    <a href="https://github.com/mkremins/flense">Flense</a>
    and
    <a href="https://github.com/darwin/plastic">Plastic</a>
    as tools with ambitious structural editing concepts for Clojure text.
  </li>

  <li>
    <a href="http://www.greenfoot.org/frames/">Frame-Based Editing</a> and
    <a href="https://scratch.mit.edu/">Scratch</a> remove parens (or curly braces)
    using blocks (like the LEGO metaphor mentioned).
  </li>

  <li>
    <a href="http://danmidwood.com/content/2014/11/21/animated-paredit.html">Paredit animations</a>
    inspired the editor animations here.
  </li>

  <li>
    <a href="https://github.com/bbatsov/clojure-style-guide#source-code-layout--organization">The Clojure Style Guide</a>
    helped me confirm some indentation conventions when formalizing Parinfer.
  </li>

  <li>
    <a href="https://twitter.com/escherize">Bryan Maass</a>
    explained to me how Lisp is like Lego&mdash; everything being the same
    shape so they can snap together any way you see fit, while other syntaxes
    have different shaped pieces which only fit together in special ways.
  </li>

  <li>
    Thanks to
    <a href="http://chrisoakman.com/">Chris Oakman</a>
    for proof-reading this page, pushing me to make an efficient implementation
    of Indent Mode, and starting the
    <a href="https://github.com/oakmac/atom-parinfer">atom-parinfer</a>
    plugin.
  </li>

  <li>
    Thanks to my friends at PROS for looking at an early draft of this page.
  </li>

  <li>
    Thanks to the Clojure/ClojureScript community for making me fall in love
    with Lisp.
  </li>

  <li>
    When John Carmack adopted Lisp (Racket) for Oculus Rift scripting,
    it gave me a little more momentum to finish writing this!
  </li>

  <li>
    I used the really cool <a href="https://github.com/liabru/gears-d3-js">gears.d3.js</a>
    library for the animated gears here.
  </li>

  <li>
    I built Parinfer as an augmentation to the
    <a href="https://codemirror.net/">CodeMirror</a>
    editor, which I really enjoyed working with and studying to learn about
    editors.
  </li>

</ul>
</section>
</div>


<section>
<div id="xkcd">
<a href="https://xkcd.com/312/"><img src="img/xkcd-frost.png"></a>
</div>
</section>

<!------------------------------------------------------------------------------------>

</div><!-- end #app -->

<div id="controls-container"></div>

<script src="codemirror/lib/codemirror.js"></script>
<script src="codemirror/addon/selection/active-line.js"></script>
<script src="codemirror/addon/edit/matchbrackets.js"></script>
<script src="codemirror/mode/javascript/javascript.js"></script>
<script src="codemirror/mode/clojure/clojure.js"></script>
<script src="codemirror/mode/clojure/clojure-parinfer.js"></script>

<script src="js/lib/scrollMonitor.js"></script>

<script src="js/lib/d3-3.3.3.min.js"></script>
<script src="js/lib/gears.d3.js"></script>

<script src="js/lib/jsdiff.min.js"></script>
<script src="parinfer.js"></script>
<script src="js/compiled/parinfer-site.js"></script>

<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$']],
      processClass: "mathjax",
      ignoreClass: "no-mathjax"
    }
  });
</script>
</body>
</html>
